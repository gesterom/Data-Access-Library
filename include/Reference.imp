//imp
#define DBG(x) {std::cout<<std::this_thread::get_id()<<"\t["<<__FUNCTION__<<" , "<<__LINE__<<" ] \t"<<#x<<std::endl;}x;
#define DB(x) {std::cout<<std::this_thread::get_id()<<"\t["<<__FUNCTION__<<" , "<<__LINE__<<" ] \t"<<#x<<std::endl;}
#define DBG_VAR(x) {std::cout<<#x<<"\t A[ "<<x<<" ]"<<std::endl;}
template<typename Type>
Reference<Type>::~Reference(){
	if(used){
		object->unlockMutex();
	}
	mMag.lock();
	manager.decrementReferenceNumber(*loader);
	mMag.unlock();
	delete loader;
}
template<typename Type>
Reference<Type>::operator Type&() {
	if(not used){
		used=true;
		mMag.lock();
		this->object = manager.getObject(*(this->loader));
		mMag.unlock();
	}
	return this->object->get();
}

template<typename Type>
Reference<Type>::Reference(ILoader<Type> * loader){
	this->loader = loader;
	mMag.lock();
	this->manager.incrementReferenceNumber(*loader);
	mMag.unlock();
}
template<typename Type>
Reference<Type>::Reference(const Reference<Type> & other){
	this->loader=other.loader->getNewPtrToCopyOfThisLader();
	mMag.lock();
	this->manager.incrementReferenceNumber(*loader);
	mMag.unlock();
}/*
template<typename Type>
Type& Reference<Type>::get(){
	if(not used){
		used=true;
		mMag.lock();
		this->object = manager.getObject(*this->loader);
		mMag.unlock();
	}
	return this->object->get();
}*/
/*
template<typename Type>
Reference<Type>& Reference<Type>::operator=(const Type & data){
	if(not used){
		used=true;
		mMag.lock();
		std::cout<<"LOADER ADRESS : "<<this->loader<<std::endl;
		this->object = manager.getObject(*this->loader);
		mMag.unlock();
	}
	this->object->get()=data;
	return *this;
}*/
